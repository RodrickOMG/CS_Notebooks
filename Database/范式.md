### 第一范式（无重复的列）

定义：数据库表的每一列都是不可分割的原子数据项，而不能是集合，数组，记录等非原子数据项。如果实体中的某个属性有多个值时，必须拆分为不同的属性

通俗解释：一个字段只存储一项信息

eg:班级：高三年1班，应改为2个字段，一个年级、一个班级，才满足第一范式

不满足第一范式

| 学号 | 姓名 | 班级      |
| ---- | ---- | --------- |
| 0001 | 小红 | 高三年1班 |

改成

| 学号 | 姓名 | 年级   | 班级 |
| ---- | ---- | ------ | ---- |
| 0001 | 小红 | 高三年 | 1班  |

### 第二范式（属性完全依赖于主键）

定义：满足第一范式前提，当存在多个主键的时候，才会发生不符合第二范式的情况。比如有两个主键，不能存在这样的属性，它只依赖于其中一个主键，这就是不符合第二范式

通俗解释：任意一个字段都只依赖表中的同一个字段

eg:比如不符合第二范式

| 学生证名称 | 学生证号 | 学生证办理时间 | 借书证名称 | 借书证号 | 借书证办理时间 |
| ---------- | -------- | -------------- | ---------- | -------- | -------------- |
|            |          |                |            |          |                |

改成2张表如下

学生证表

| 学生证 | 学生证号 | 学生证办理时间 |
| ------ | -------- | -------------- |
|        |          |                |

借书证表

| 借书证 | 借书证号 | 借书证把你拉时间 |
| ------ | -------- | ---------------- |
|        |          |                  |

### 第三范式（属性不能传递依赖于主属性）

定义：满足第二范式前提，如果某一属性依赖于其他非主键属性，而其他非主键属性又依赖于主键，那么这个属性就是间接依赖于主键，这被称作传递依赖于主属性。

通俗理解：一张表最多只存2层同类型信息

eg:爸爸资料表，不满足第三范式

| 爸爸 | 儿子 | 女儿 | 女儿的小熊 | 女儿的海绵宝宝 |
| ---- | ---- | ---- | ---------- | -------------- |
|      |      |      |            |                |

改成

爸爸信息表：

| 爸爸 | 儿子 | 女儿 |
| ---- | ---- | ---- |
|      |      |      |

女儿信息表

| 女儿 | 女儿的小熊 | 女儿的海绵宝宝 |
| ---- | ---------- | -------------- |
|      |            |                |

### **BCNF范式**

要了解 BCNF 范式，那么先看这样一个问题：
若：

1. 某公司有若干个仓库；
2. 每个仓库只能有一名管理员，一名管理员只能在一个仓库中工作；
3. 一个仓库中可以存放多种物品，一种物品也可以存放在不同的仓库中。每种物品在每个仓库中都有对应的数量。

那么关系模式 仓库（仓库名，管理员，物品名，数量） 属于哪一级范式？

答：已知函数依赖集：仓库名 → 管理员，管理员 → 仓库名，（仓库名，物品名）→ 数量
码：（管理员，物品名），（仓库名，物品名）
主属性：仓库名、管理员、物品名
非主属性：数量
∵ 不存在非主属性对码的部分函数依赖和传递函数依赖。∴ 此关系模式属于3NF。

基于此关系模式的关系（具体的数据）可能如图所示：

![img](https://pic3.zhimg.com/80/68d080d437732aad8cfe451b427849d6_1440w.jpg)



好，既然此关系模式已经属于了 3NF，那么这个关系模式是否存在问题呢？我们来看以下几种操作：



1. 先新增加一个仓库，但尚未存放任何物品，是否可以为该仓库指派管理员？——不可以，因为物品名也是主属性，根据实体完整性的要求，主属性不能为空。
2. 某仓库被清空后，需要删除所有与这个仓库相关的物品存放记录，会带来什么问题？——仓库本身与管理员的信息也被随之删除了。
3. 如果某仓库更换了管理员，会带来什么问题？——这个仓库有几条物品存放记录，就要修改多少次管理员信息。

从这里我们可以得出结论，在某些特殊情况下，即使关系模式符合 3NF 的要求，仍然存在着插入异常，修改异常与删除异常的问题，仍然不是 ”好“ 的设计。

造成此问题的原因：存在着**主属性**对于码的部分函数依赖与传递函数依赖。（在此例中就是存在主属性【仓库名】对于码【（管理员，物品名）】的部分函数依赖。

解决办法就是要在 3NF 的基础上消除**主属性**对于码的部分与传递函数依赖。

仓库（仓库名，管理员）
库存（仓库名，物品名，数量）

这样，之前的插入异常，修改异常与删除异常的问题就被解决了。

以上就是关于 BCNF 的解释。


几个典型习题及其解答吧。
===============================
问题1：

[李德竹](http://www.zhihu.com/people/li-de-zhu-84) ：老师您好，我看了您关于数据库范式的回答，有一点不太理解，就是关于码的定义，如果除K之外的所有属性都完全函数依赖于K时才能称K为码，那么在判断2NF时又怎么会存在非主属性对码的部分函数依赖这种情况？希望老师有时间能指点一下，谢谢

我 ：在“码”的定义中，除 K 之外的所有属性应该看成是一个集合 U（也就是一个整体），也就是说，只有 K 能够完全函数决定 U 中的每一个属性，那么 K 才是码。如果 K 只是能够完全函数决定 U 中的一部分属性，而不能完全函数决定另外一部分属性，那么 K 不是码。

比如有关系模式 R (Sno, Sname, Cno, Cname, Sdept, Sloc, Grade)，其中函数依赖集为 F= {Sno → Sname, Sno → Sdept, Sdept → Sloc，Sno → Sloc, Cno → Cname, (Sno, Cno) → Grade }

那么 R 中的码只能是 (Sno, Cno)，Sno 或 Cno 并不能完全函数决定除 Sno / Cno 之外的所有其他属性（其实就是不能决定 Grade )，所以单独的 Sno 与 Cno 并不能作为码。

所以可得到主属性：Sno, Cno

非主属性：Sname, Cname, Sdept, Sloc, Grade

R 中存在非主属性 Cname 对于码 (Sno, Cno) 的部分函数依赖 (Cno → Cname) 。（还有很多别的例子就不一一列举了）。所以 R 不符合 2NF 的要求。

===================================
问题2：

（推导过程比较复杂，直接在 SP3 上手写了，请忽略难看的字。）

已知有关系模式 R(A, B, C, D)，已知有函数依赖集：{(A, B)→C, C→D D→A}，问关系模式 R 最高支持第几范式？

![img](https://pic1.zhimg.com/80/fe2721b0fe0b75097a863e653bcc7738_1440w.jpg)



====================================

问题3：

已知有关系模式R(A, B, C, D)，已知有函数依赖集：{A→B, A→C, A→ D, B→D, (B, C)→A }。问关系模式 R 最高支持第几范式？

![img](https://pic2.zhimg.com/80/93b184d5a6dd2d51d8434e48fc7e5455_1440w.jpg)